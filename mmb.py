import cv2
import numpy as np


class MMB:
    # HYPER PARAMETERS
    K = 4  # Eq. 4 in MMB paper
    AREA_MIN = 5  # Eq. 7 in MMB paper
    AREA_MAX = 80  # Eq. 7 in MMB paper
    ASPECT_RATIO_MIN = 1.0  # Eq. 7 in MMB paper
    ASPECT_RATIO_MAX = 6.0  # Eq. 7 in MMB paper
    L = 4  # Eq. 9 in MMB paper
    KERNAL = np.ones((3, 3), np.uint8)  # Algorithm 1 in MMB paper
    PIPELINE_LENGTH = 5  # Step 1 of Pipeline Filter in MMB paper
    PIPELINE_SIZE = (7, 7)  # Step 1 of Pipeline Filter in MMB paper
    H = 3  # Step 4 of Pipeline Filter in MMB paper

    def __init__(self, file_path):
        self.capture = cv2.VideoCapture(file_path)
        if not self.capture.isOpened():
            raise ValueError(f"Unable to open video: {file_path}")

        # Read first L + 3 frames.
        # AMFD needs a previous frame a current frame and a next frame.
        # LRMC needs L frames past the current frame. (TODO: Check this)
        self.mod_frame_buffer = [self._read_frame() for _ in range(3 + self.L)]

        # Initialize pipeline buffers.
        # Pipeline will be filled with PIPELINE_LENGTH + 1 frames and masks. (TODO: Check this)
        # The Pipeline filter needs to have PINEPIPE_LENGTH plus the current frame and mask generated by AMFD and LRMC.
        self.pipeline_mask_buffer = []
        self.pipeline_frame_buffer = []

        # Fill pipeline buffers with 1 + PIPELINE_LENGTH frames and masks.
        for _ in range(1 + self.PIPELINE_LENGTH):
            amfd_mask = self.accumulative_multiframe_differencing()
            lrmc_mask = self.low_rank_matrix_completion()
            self.pipeline_mask_buffer.append(
                cv2.bitwise_and(amfd_mask, lrmc_mask)
            )  # (TODO: Check this. Not sure if "element-wise multiplication" means "bitwise_and")
            self.pipeline_frame_buffer.append(self.mod_frame_buffer[1])
            self.mod_frame_buffer.pop(0)
            self.mod_frame_buffer.append(self._read_frame())

    def _read_frame(self):
        ret, frame = self.capture.read()
        if not ret:
            raise ValueError(f"Unable to read frame.")
        return frame

    # Externally callable function to process next frame. 
    # Warning: The frame and mask that gets returned lags way behind the head frame.
    def process_next_frame(self):
        amfd_mask = self.accumulative_multiframe_differencing()
        lrmc_mask = self.low_rank_matrix_completion()
        self.pipeline_mask_buffer.append(
            cv2.bitwise_and(amfd_mask, lrmc_mask)
        )  # (TODO: Check this. Not sure if "element-wise multiplication" means "bitwise_and")

        # Remember, AMFD needs a previous frame which is set to mod_frame_buffer[0], 
        # so current frame is mod_frame_buffer[1] 
        # (a.k.a the mask that was generated and appended to pipeline_mask_buffer was for mod_frame_buffer[1])
        self.pipeline_frame_buffer.append(self.mod_frame_buffer[1])

        # Cleans up pipeline_mask_buffer[0] which is the mask thats about to be returned
        self.pipeline_filter()

        # Pop the oldest frame and mask from the pipeline filter buffers to be returned.
        return_frame, return_mask = self.pipeline_frame_buffer.pop(
            0
        ), self.pipeline_mask_buffer.pop(0)

        # Get the next frame and append it to the mod_frame_buffer for next iteration.
        self.mod_frame_buffer.pop(0)
        next_frame = self._read_frame()
        if next_frame is None:
            print("End of video reached.")
            return None, None
        self.mod_frame_buffer.append(next_frame)

        return return_frame, return_mask

    def accumulative_multiframe_differencing(self):
        prev_frame, current_frame, next_frame = (
            self.mod_frame_buffer[0],
            self.mod_frame_buffer[1],
            self.mod_frame_buffer[2],
        )

        # Calculate the differencing images Dt1, Dt2, Dt3
        # Dt1 = |It - It-1| (Eq. 1 in MMB paper)
        Dt1 = cv2.absdiff(current_frame, prev_frame)
        # Dt2 = |It+1 - It-1| (Eq. 2 in MMB paper)
        Dt2 = cv2.absdiff(next_frame, prev_frame)
        # Dt3 = |It+1 - It| (Eq. 3 in MMB paper)
        Dt3 = cv2.absdiff(next_frame, current_frame)

        # Calculate the accumulative response image Id
        # Id = (Dt1 + Dt2 + Dt3) / 3 (Eq. 4 in MMB paper)
        Id = (Dt1 + Dt2 + Dt3) / 3
        Id_gray = cv2.cvtColor(Id.astype(np.uint8), cv2.COLOR_BGR2GRAY)

        # Calculate the threshold T to extract targets
        mean_val, std_val = cv2.meanStdDev(Id_gray)
        # T = mean + k + std (Eq. 6 in MMB paper)
        T = mean_val[0][0] + self.K * std_val[0][0]

        # Convert the accumulative response image to a binary image
        # Id(x, y) = 255 if Id(x, y) >= T, 0 otherwise (Eq. 5 in MMB paper
        _, binary_image = cv2.threshold(Id_gray, T, 255, cv2.THRESH_BINARY)

        # Perform morphological operations on binary image
        binary_image = cv2.morphologyEx(binary_image, cv2.MORPH_OPEN, self.KERNAL)

        # Remove false alarms
        # Connected area  must satisfy the following conditions:
        # 1. Area must be between AREA_MIN and AREA_MAX
        # 2. Aspect ratio must be between ASPECT_RATIO_MIN and ASPECT_RATIO_MAX (Eq. 7 in MMB paper)
        contours, _ = cv2.findContours(
            binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE
        )
        for cnt in contours:
            area = cv2.contourArea(cnt)
            x, y, w, h = cv2.boundingRect(cnt)
            aspect_ratio = float(w) / h
            if (
                area < self.AREA_MIN
                or area > self.AREA_MAX
                or aspect_ratio < self.ASPECT_RATIO_MIN
                or aspect_ratio > self.ASPECT_RATIO_MAX
            ):
                cv2.drawContours(binary_image, [cnt], 0, 0, -1)

        return binary_image

    def low_rank_matrix_completion(self):
        # TODO: https://github.com/ostadabbas/fRMC
        # Return white mask for now
        return np.ones(self.mod_frame_buffer[1].shape[:2], dtype=np.uint8) * 255

    def pipeline_filter(self):
        # TODO: See MMB paper section D
        pass
